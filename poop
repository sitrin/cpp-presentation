/usr/include/c++/7/bits/locale_facets.h:1082:7: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/locale_facets.h:1083:16: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/locale_facets.h:1083:16: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/bits/char_traits.h:314:7: note: vectorized 0 loops in function.
/usr/include/c++/7/bits/char_traits.h:314:7: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/char_traits.h:320:29: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/char_traits.h:320:29: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at lcg.cpp:25
lcg.cpp:25:5: note: ===== analyze_loop_nest =====
lcg.cpp:25:5: note: === vect_analyze_loop_form ===
lcg.cpp:25:5: note: === get_loop_niters ===
lcg.cpp:25:5: note: Symbolic number of iterations is (((unsigned long) _9 - (unsigned long) ((const value_type *) _7 + 4)) /[ex] 4 & 4611686018427387903) + 1
lcg.cpp:25:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed
lcg.cpp:20:6: note: vectorized 0 loops in function.
lcg.cpp:20:6: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/basic_ios.h:372:2: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: _16 = cout._vptr.basic_ostream;
vector(8) long unsigned int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: _17 = MEM[(long int *)_16 + -24B];
vector(8) long int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: __old_35 = _19->_M_flags;
vector(16) signed int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: MEM[(_Ios_Fmtflags &)_19 + 24] = _37;
vector(16) signed int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: MEM[(streamsize *)_19 + 16B] = 4;
vector(8) long int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: _29 = MEM[(long int *)_16 + -24B];
vector(8) long int
/usr/include/c++/7/bits/basic_ios.h:372:2: note: got vectype for stmt: _33 = MEM[(const struct basic_ios *)_31]._M_fill_init;
vector(64) unsigned char
/usr/include/c++/7/bits/basic_ios.h:372:2: note: === vect_analyze_data_ref_accesses ===
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access __old_35 = _19->_M_flags;
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access MEM[(streamsize *)_19 + 16B] = 4;
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access MEM[(_Ios_Fmtflags &)_19 + 24] = _37;
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access _33 = MEM[(const struct basic_ios *)_31]._M_fill_init;
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access _16 = cout._vptr.basic_ostream;
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access _17 = MEM[(long int *)_16 + -24B];
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not consecutive access _29 = MEM[(long int *)_16 + -24B];
/usr/include/c++/7/bits/basic_ios.h:372:2: note: not vectorized: no grouped stores in basic block.
/usr/include/c++/7/bits/basic_ios.h:372:2: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/basic_ios.h:49:7: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/basic_ios.h:49:7: note: got vectype for stmt: _38 = MEM[(const struct basic_ios *)_31]._M_ctype;
vector(8) long unsigned int
/usr/include/c++/7/bits/basic_ios.h:49:7: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/bits/basic_ios.h:49:7: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/basic_ios.h:50:18: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/locale_facets.h:874:2: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/locale_facets.h:874:2: note: got vectype for stmt: _40 = MEM[(const struct ctype *)_38]._M_widen_ok;
vector(64) char
/usr/include/c++/7/bits/locale_facets.h:874:2: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/bits/locale_facets.h:874:2: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/locale_facets.h:874:2: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/locale_facets.h:877:27: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/locale_facets.h:877:27: note: got vectype for stmt: _47 = MEM[(const struct ctype *)_38].D.65888._vptr.facet;
vector(8) long unsigned int
/usr/include/c++/7/bits/locale_facets.h:877:27: note: got vectype for stmt: _48 = MEM[(int (*__vtbl_ptr_type) () *)_47 + 48B];
vector(8) long unsigned int
/usr/include/c++/7/bits/locale_facets.h:877:27: note: === vect_analyze_data_ref_accesses ===
/usr/include/c++/7/bits/locale_facets.h:877:27: note: not consecutive access _47 = MEM[(const struct ctype *)_38].D.65888._vptr.facet;
/usr/include/c++/7/bits/locale_facets.h:877:27: note: not consecutive access _48 = MEM[(int (*__vtbl_ptr_type) () *)_47 + 48B];
/usr/include/c++/7/bits/locale_facets.h:877:27: note: not vectorized: no grouped stores in basic block.
/usr/include/c++/7/bits/locale_facets.h:877:27: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/locale_facets.h:877:27: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/bits/basic_ios.h:375:6: note: === vect_analyze_data_refs ===
/usr/include/c++/7/bits/basic_ios.h:375:6: note: got vectype for stmt: MEM[(const struct basic_ios *)_31]._M_fill_init = 1;
vector(64) unsigned char
/usr/include/c++/7/bits/basic_ios.h:375:6: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/bits/basic_ios.h:375:6: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/array:139:43: note: === vect_analyze_data_refs ===
/usr/include/c++/7/array:139:43: note: got vectype for stmt: _31->_M_fill = 48;
vector(64) char
/usr/include/c++/7/array:139:43: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/array:139:43: note: ===vect_slp_analyze_bb===
lcg.cpp:29:1: note: === vect_analyze_data_refs ===
lcg.cpp:29:1: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:29:1: note: ===vect_slp_analyze_bb===
lcg.cpp:29:1: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/ostream:185:50: note: === vect_analyze_data_refs ===
/usr/include/c++/7/ostream:185:50: note: got vectype for stmt: s_8 = *__for_begin_99;
const vector(16) unsigned int
/usr/include/c++/7/ostream:185:50: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:25:5: note: === vect_analyze_data_refs ===
lcg.cpp:25:5: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at lcg.cpp:45
lcg.cpp:45:22: note: ===== analyze_loop_nest =====
lcg.cpp:45:22: note: === vect_analyze_loop_form ===
lcg.cpp:45:22: note: === vect_analyze_loop_form ===
lcg.cpp:45:22: note: === get_loop_niters ===
lcg.cpp:45:22: note: Considering outer-loop vectorization.
lcg.cpp:45:22: note: === get_loop_niters ===
lcg.cpp:45:22: note: === vect_analyze_data_refs ===
lcg.cpp:45:22: note: got vectype for stmt: _1 = MEM[(const value_type &)&SEED][i_73];
const vector(16) unsigned int
lcg.cpp:45:22: note: got vectype for stmt: MEM[(value_type &)&state][i_73] = _1;
const vector(16) unsigned int
lcg.cpp:45:22: note: got vectype for stmt: MEM[(uint32_t &)&state][i_73] = _79;
const vector(16) unsigned int
lcg.cpp:45:22: note: === vect_analyze_scalar_cycles ===
lcg.cpp:45:22: note: Analyze phi: i_73 = PHI <i_21(7), 0(2)>
lcg.cpp:45:22: note: Access function of PHI: {0, +, 1}_1
lcg.cpp:45:22: note: step: 1,  init: 0
lcg.cpp:45:22: note: Detected induction.
lcg.cpp:45:22: note: Analyze phi: .MEM_75 = PHI <.MEM_5(7), .MEM_16(2)>
lcg.cpp:45:22: note: Analyze phi: ivtmp_87 = PHI <ivtmp_86(7), 8(2)>
lcg.cpp:45:22: note: Access function of PHI: {8, +, 18446744073709551615}_1
lcg.cpp:45:22: note: step: 18446744073709551615,  init: 8
lcg.cpp:45:22: note: Detected induction.
lcg.cpp:45:22: note: === vect_analyze_scalar_cycles ===
lcg.cpp:45:22: note: Analyze phi: j_74 = PHI <j_20(5), 0(3)>
lcg.cpp:45:22: note: Access function of PHI: {0, +, 1}_2
lcg.cpp:45:22: note: step: 1,  init: 0
lcg.cpp:45:22: note: Detected induction.
lcg.cpp:45:22: note: Analyze phi: .MEM_76 = PHI <.MEM_76(5), .MEM_19(3)>
lcg.cpp:45:22: note: Analyze phi: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:45:22: note: Access function of PHI: state__I_lsm.104_3
lcg.cpp:45:22: note: Analyze phi: ivtmp_2 = PHI <ivtmp_88(5), 100000000(3)>
lcg.cpp:45:22: note: Access function of PHI: {100000000, +, 4294967295}_2
lcg.cpp:45:22: note: step: 4294967295,  init: 100000000
lcg.cpp:45:22: note: Detected induction.
lcg.cpp:45:22: note: Analyze phi: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:45:22: note: reduction: unknown pattern: _33 = _32 & 2147483647;
lcg.cpp:45:22: note: Unknown def-use cycle pattern.
lcg.cpp:45:22: note: === vect_pattern_recog ===
lcg.cpp:45:22: note: vect_is_simple_use: operand state__I_lsm.104_3
lcg.cpp:45:22: note: def_stmt: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:45:22: note: type of def: unknown
lcg.cpp:45:22: note: Unsupported pattern.
lcg.cpp:45:22: note: vect_is_simple_use: operand _32
lcg.cpp:45:22: note: def_stmt: _32 = _17 + 2531011;
lcg.cpp:45:22: note: type of def: internal
lcg.cpp:45:22: note: === vect_analyze_data_ref_accesses ===
lcg.cpp:45:22: note: === vect_mark_stmts_to_be_vectorized ===
lcg.cpp:45:22: note: init: phi relevant? i_73 = PHI <i_21(7), 0(2)>
lcg.cpp:45:22: note: init: phi relevant? .MEM_75 = PHI <.MEM_5(7), .MEM_16(2)>
lcg.cpp:45:22: note: init: phi relevant? ivtmp_87 = PHI <ivtmp_86(7), 8(2)>
lcg.cpp:45:22: note: init: stmt relevant? _1 = MEM[(const value_type &)&SEED][i_73];
lcg.cpp:45:22: note: init: stmt relevant? MEM[(value_type &)&state][i_73] = _1;
lcg.cpp:45:22: note: vec_stmt_relevant_p: stmt has vdefs.
lcg.cpp:45:22: note: mark relevant 5, live 0: MEM[(value_type &)&state][i_73] = _1;
lcg.cpp:45:22: note: init: phi relevant? j_74 = PHI <j_20(5), 0(3)>
lcg.cpp:45:22: note: init: phi relevant? .MEM_76 = PHI <.MEM_76(5), .MEM_19(3)>
lcg.cpp:45:22: note: init: phi relevant? state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:45:22: note: init: phi relevant? ivtmp_2 = PHI <ivtmp_88(5), 100000000(3)>
lcg.cpp:45:22: note: init: stmt relevant? _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:45:22: note: init: stmt relevant? _32 = _17 + 2531011;
lcg.cpp:45:22: note: init: stmt relevant? _33 = _32 & 2147483647;
lcg.cpp:45:22: note: init: stmt relevant? j_20 = j_74 + 1;
lcg.cpp:45:22: note: init: stmt relevant? ivtmp_88 = ivtmp_2 - 1;
lcg.cpp:45:22: note: init: stmt relevant? if (ivtmp_88 == 0)
lcg.cpp:45:22: note: init: phi relevant? _79 = PHI <_33(4)>
lcg.cpp:45:22: note: init: stmt relevant? MEM[(uint32_t &)&state][i_73] = _79;
lcg.cpp:45:22: note: vec_stmt_relevant_p: stmt has vdefs.
lcg.cpp:45:22: note: mark relevant 5, live 0: MEM[(uint32_t &)&state][i_73] = _79;
lcg.cpp:45:22: note: init: stmt relevant? i_21 = i_73 + 1;
lcg.cpp:45:22: note: init: stmt relevant? ivtmp_86 = ivtmp_87 - 1;
lcg.cpp:45:22: note: init: stmt relevant? if (ivtmp_86 == 0)
lcg.cpp:45:22: note: worklist: examine stmt: MEM[(uint32_t &)&state][i_73] = _79;
lcg.cpp:45:22: note: vect_is_simple_use: operand _79
lcg.cpp:45:22: note: def_stmt: _79 = PHI <_33(4)>
lcg.cpp:45:22: note: type of def: internal
lcg.cpp:45:22: note: mark relevant 5, live 0: _79 = PHI <_33(4)>
lcg.cpp:45:22: note: worklist: examine stmt: _79 = PHI <_33(4)>
lcg.cpp:45:22: note: vect_is_simple_use: operand _33
lcg.cpp:45:22: note: def_stmt: _33 = _32 & 2147483647;
lcg.cpp:45:22: note: type of def: internal
lcg.cpp:45:22: note: inner-loop def-stmt defining outer-loop stmt.
lcg.cpp:45:22: note: mark relevant 3, live 0: _33 = _32 & 2147483647;
lcg.cpp:45:22: note: worklist: examine stmt: _33 = _32 & 2147483647;
lcg.cpp:45:22: note: vect_is_simple_use: operand _32
lcg.cpp:45:22: note: def_stmt: _32 = _17 + 2531011;
lcg.cpp:45:22: note: type of def: internal
lcg.cpp:45:22: note: mark relevant 3, live 0: _32 = _17 + 2531011;
lcg.cpp:45:22: note: worklist: examine stmt: _32 = _17 + 2531011;
lcg.cpp:45:22: note: vect_is_simple_use: operand _17
lcg.cpp:45:22: note: def_stmt: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:45:22: note: type of def: internal
lcg.cpp:45:22: note: mark relevant 3, live 0: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:45:22: note: worklist: examine stmt: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:45:22: note: vect_is_simple_use: operand state__I_lsm.104_3
lcg.cpp:45:22: note: def_stmt: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:45:22: note: type of def: unknown
lcg.cpp:45:22: note: Unsupported pattern.
lcg.cpp:45:22: note: not vectorized: unsupported use in stmt.
lcg.cpp:45:22: note: unexpected pattern.

Analyzing loop at lcg.cpp:48
lcg.cpp:48:31: note: ===== analyze_loop_nest =====
lcg.cpp:48:31: note: === vect_analyze_loop_form ===
lcg.cpp:48:31: note: === get_loop_niters ===
lcg.cpp:48:31: note: === vect_analyze_data_refs ===
lcg.cpp:48:31: note: === vect_analyze_scalar_cycles ===
lcg.cpp:48:31: note: Analyze phi: j_74 = PHI <j_20(5), 0(3)>
lcg.cpp:48:31: note: Access function of PHI: {0, +, 1}_2
lcg.cpp:48:31: note: step: 1,  init: 0
lcg.cpp:48:31: note: Detected induction.
lcg.cpp:48:31: note: Analyze phi: .MEM_76 = PHI <.MEM_76(5), .MEM_19(3)>
lcg.cpp:48:31: note: Analyze phi: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:48:31: note: Access function of PHI: state__I_lsm.104_3
lcg.cpp:48:31: note: Analyze phi: ivtmp_2 = PHI <ivtmp_88(5), 100000000(3)>
lcg.cpp:48:31: note: Access function of PHI: {100000000, +, 4294967295}_2
lcg.cpp:48:31: note: step: 4294967295,  init: 100000000
lcg.cpp:48:31: note: Detected induction.
lcg.cpp:48:31: note: Analyze phi: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:48:31: note: reduction: unknown pattern: _33 = _32 & 2147483647;
lcg.cpp:48:31: note: Unknown def-use cycle pattern.
lcg.cpp:48:31: note: === vect_pattern_recog ===
lcg.cpp:48:31: note: vect_is_simple_use: operand state__I_lsm.104_3
lcg.cpp:48:31: note: def_stmt: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:48:31: note: type of def: unknown
lcg.cpp:48:31: note: Unsupported pattern.
lcg.cpp:48:31: note: vect_is_simple_use: operand _32
lcg.cpp:48:31: note: def_stmt: _32 = _17 + 2531011;
lcg.cpp:48:31: note: type of def: internal
lcg.cpp:48:31: note: === vect_analyze_data_ref_accesses ===
lcg.cpp:48:31: note: === vect_mark_stmts_to_be_vectorized ===
lcg.cpp:48:31: note: init: phi relevant? j_74 = PHI <j_20(5), 0(3)>
lcg.cpp:48:31: note: init: phi relevant? .MEM_76 = PHI <.MEM_76(5), .MEM_19(3)>
lcg.cpp:48:31: note: init: phi relevant? state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:48:31: note: init: phi relevant? ivtmp_2 = PHI <ivtmp_88(5), 100000000(3)>
lcg.cpp:48:31: note: init: stmt relevant? _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:48:31: note: init: stmt relevant? _32 = _17 + 2531011;
lcg.cpp:48:31: note: init: stmt relevant? _33 = _32 & 2147483647;
lcg.cpp:48:31: note: vec_stmt_relevant_p: used out of loop.
lcg.cpp:48:31: note: vect_is_simple_use: operand _32
lcg.cpp:48:31: note: def_stmt: _32 = _17 + 2531011;
lcg.cpp:48:31: note: type of def: internal
lcg.cpp:48:31: note: vec_stmt_relevant_p: stmt live but not relevant.
lcg.cpp:48:31: note: mark relevant 1, live 1: _33 = _32 & 2147483647;
lcg.cpp:48:31: note: init: stmt relevant? j_20 = j_74 + 1;
lcg.cpp:48:31: note: init: stmt relevant? ivtmp_88 = ivtmp_2 - 1;
lcg.cpp:48:31: note: init: stmt relevant? if (ivtmp_88 == 0)
lcg.cpp:48:31: note: worklist: examine stmt: _33 = _32 & 2147483647;
lcg.cpp:48:31: note: vect_is_simple_use: operand _32
lcg.cpp:48:31: note: def_stmt: _32 = _17 + 2531011;
lcg.cpp:48:31: note: type of def: internal
lcg.cpp:48:31: note: mark relevant 1, live 0: _32 = _17 + 2531011;
lcg.cpp:48:31: note: worklist: examine stmt: _32 = _17 + 2531011;
lcg.cpp:48:31: note: vect_is_simple_use: operand _17
lcg.cpp:48:31: note: def_stmt: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:48:31: note: type of def: internal
lcg.cpp:48:31: note: mark relevant 1, live 0: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:48:31: note: worklist: examine stmt: _17 = state__I_lsm.104_3 * 214013;
lcg.cpp:48:31: note: vect_is_simple_use: operand state__I_lsm.104_3
lcg.cpp:48:31: note: def_stmt: state__I_lsm.104_3 = PHI <_33(5), _1(3)>
lcg.cpp:48:31: note: type of def: unknown
lcg.cpp:48:31: note: Unsupported pattern.
lcg.cpp:48:31: note: not vectorized: unsupported use in stmt.
lcg.cpp:48:31: note: unexpected pattern.
lcg.cpp:31:5: note: vectorized 0 loops in function.
lcg.cpp:31:5: note: ===vect_slp_analyze_bb===
lcg.cpp:43:49: note: === vect_analyze_data_refs ===
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[0] = 67;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[1] = 79;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[2] = 76;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[3] = 85;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[4] = 77;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[5] = 66;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[6] = 73;
vector(16) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[7] = 65;
vector(16) unsigned int
lcg.cpp:43:49: note: not vectorized: no vectype for stmt: state = {};
 scalar_type: struct array
lcg.cpp:43:49: note: === vect_analyze_data_ref_accesses ===
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[1]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[2]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[3]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[4]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[5]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[6]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[7]
lcg.cpp:43:49: note: Detected interleaving store of size 8 starting with SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: === vect_pattern_recog ===
lcg.cpp:43:49: note: === vect_analyze_slp ===
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: Build SLP failed: unrolling required in basic block SLP
lcg.cpp:43:49: note: ***** Re-trying analysis with vector size 32
lcg.cpp:43:49: note: === vect_analyze_data_refs ===
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[0] = 67;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[1] = 79;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[2] = 76;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[3] = 85;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[4] = 77;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[5] = 66;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[6] = 73;
vector(8) unsigned int
lcg.cpp:43:49: note: got vectype for stmt: SEED._M_elems[7] = 65;
vector(8) unsigned int
lcg.cpp:43:49: note: not vectorized: no vectype for stmt: state = {};
 scalar_type: struct array
lcg.cpp:43:49: note: === vect_analyze_data_ref_accesses ===
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[1]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[2]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[3]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[4]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[5]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[6]
lcg.cpp:43:49: note: Detected interleaving store SEED._M_elems[0] and SEED._M_elems[7]
lcg.cpp:43:49: note: Detected interleaving store of size 8 starting with SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: === vect_pattern_recog ===
lcg.cpp:43:49: note: === vect_analyze_slp ===
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[1] = 79;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[2] = 76;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[3] = 85;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[4] = 77;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[5] = 66;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[6] = 73;
lcg.cpp:43:49: note: Build SLP for SEED._M_elems[7] = 65;
lcg.cpp:43:49: note: vect_is_simple_use: operand 67
lcg.cpp:43:49: note: vect_is_simple_use: operand 79
lcg.cpp:43:49: note: vect_is_simple_use: operand 76
lcg.cpp:43:49: note: vect_is_simple_use: operand 85
lcg.cpp:43:49: note: vect_is_simple_use: operand 77
lcg.cpp:43:49: note: vect_is_simple_use: operand 66
lcg.cpp:43:49: note: vect_is_simple_use: operand 73
lcg.cpp:43:49: note: vect_is_simple_use: operand 65
lcg.cpp:43:49: note: Final SLP tree for instance:
lcg.cpp:43:49: note: node
lcg.cpp:43:49: note: 	stmt 0 SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: 	stmt 1 SEED._M_elems[1] = 79;
lcg.cpp:43:49: note: 	stmt 2 SEED._M_elems[2] = 76;
lcg.cpp:43:49: note: 	stmt 3 SEED._M_elems[3] = 85;
lcg.cpp:43:49: note: 	stmt 4 SEED._M_elems[4] = 77;
lcg.cpp:43:49: note: 	stmt 5 SEED._M_elems[5] = 66;
lcg.cpp:43:49: note: 	stmt 6 SEED._M_elems[6] = 73;
lcg.cpp:43:49: note: 	stmt 7 SEED._M_elems[7] = 65;
lcg.cpp:43:49: note: === vect_slp_analyze_and_verify_instance_alignment ===
lcg.cpp:43:49: note: vect_compute_data_ref_alignment:
lcg.cpp:43:49: note: force alignment of SEED._M_elems[0]
lcg.cpp:43:49: note: misalign = 0 bytes of ref SEED._M_elems[0]
lcg.cpp:43:49: note: === vect_slp_analyze_instance_dependence ===
lcg.cpp:43:49: note: === vect_slp_analyze_operations ===
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: vect_is_simple_use: operand 67
lcg.cpp:43:49: note: vect_is_simple_use: operand 79
lcg.cpp:43:49: note: vect_is_simple_use: operand 76
lcg.cpp:43:49: note: vect_is_simple_use: operand 85
lcg.cpp:43:49: note: vect_is_simple_use: operand 77
lcg.cpp:43:49: note: vect_is_simple_use: operand 66
lcg.cpp:43:49: note: vect_is_simple_use: operand 73
lcg.cpp:43:49: note: vect_is_simple_use: operand 65
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[1] = 79;
lcg.cpp:43:49: note: vect_is_simple_use: operand 79
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[2] = 76;
lcg.cpp:43:49: note: vect_is_simple_use: operand 76
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[3] = 85;
lcg.cpp:43:49: note: vect_is_simple_use: operand 85
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[4] = 77;
lcg.cpp:43:49: note: vect_is_simple_use: operand 77
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[5] = 66;
lcg.cpp:43:49: note: vect_is_simple_use: operand 66
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[6] = 73;
lcg.cpp:43:49: note: vect_is_simple_use: operand 73
lcg.cpp:43:49: note: ==> examining statement: SEED._M_elems[7] = 65;
lcg.cpp:43:49: note: vect_is_simple_use: operand 65
lcg.cpp:43:49: note: === vect_analyze_slp_cost ===
lcg.cpp:43:49: note: vect_model_store_cost: aligned.
lcg.cpp:43:49: note: vect_model_store_cost: inside_cost = 1, prologue_cost = 0 .
lcg.cpp:43:49: note: vect_is_simple_use: operand 67
lcg.cpp:43:49: note: Cost model analysis: 
  Vector inside of basic block cost: 1
  Vector prologue cost: 1
  Vector epilogue cost: 0
  Scalar cost of basic block: 8
lcg.cpp:43:49: note: Basic block will be vectorized using SLP
lcg.cpp:43:49: note: SLPing BB part
lcg.cpp:43:49: note: ------>vectorizing SLP node starting from: SEED._M_elems[0] = 67;
lcg.cpp:43:49: note: vect_is_simple_use: operand 67
lcg.cpp:43:49: note: vect_is_simple_use: operand 79
lcg.cpp:43:49: note: vect_is_simple_use: operand 76
lcg.cpp:43:49: note: vect_is_simple_use: operand 85
lcg.cpp:43:49: note: vect_is_simple_use: operand 77
lcg.cpp:43:49: note: vect_is_simple_use: operand 66
lcg.cpp:43:49: note: vect_is_simple_use: operand 73
lcg.cpp:43:49: note: vect_is_simple_use: operand 65
lcg.cpp:43:49: note: transform store. ncopies = 1
lcg.cpp:43:49: note: created new init_stmt: vect_cst__74 = { 67, 79, 76, 85, 77, 66, 73, 65 };
lcg.cpp:43:49: note: create vector_type-pointer variable to type: vector(8) unsigned int  vectorizing a pointer ref: SEED._M_elems[0]
lcg.cpp:43:49: note: created &SEED._M_elems[0]
lcg.cpp:43:49: note: add new stmt: MEM[(unsigned int *)&SEED] = vect_cst__74;
lcg.cpp:43:49: note: vectorizing stmts using SLP.
lcg.cpp:43:49: note: basic block part vectorized
lcg.cpp:43:49: note: basic block vectorized
lcg.cpp:43:49: note: ===vect_slp_analyze_bb===
lcg.cpp:47:18: note: === vect_analyze_data_refs ===
lcg.cpp:47:18: note: got vectype for stmt: _1 = MEM[(const value_type &)&SEED][i_73];
const vector(16) unsigned int
lcg.cpp:47:18: note: got vectype for stmt: MEM[(value_type &)&state][i_73] = _1;
const vector(16) unsigned int
lcg.cpp:47:18: note: === vect_analyze_data_ref_accesses ===
lcg.cpp:47:18: note: not vectorized: no grouped stores in basic block.
lcg.cpp:47:18: note: ===vect_slp_analyze_bb===
lcg.cpp:48:31: note: === vect_analyze_data_refs ===
lcg.cpp:48:31: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:48:31: note: ===vect_slp_analyze_bb===
lcg.cpp:48:31: note: ===vect_slp_analyze_bb===
lcg.cpp:45:22: note: === vect_analyze_data_refs ===
lcg.cpp:45:22: note: got vectype for stmt: MEM[(uint32_t &)&state][i_73] = _79;
const vector(16) unsigned int
lcg.cpp:45:22: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:45:22: note: ===vect_slp_analyze_bb===
lcg.cpp:45:22: note: ===vect_slp_analyze_bb===
/usr/include/c++/7/ostream:562:44: note: === vect_analyze_data_refs ===
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: SR.52_40 = MEM[(const struct time_point *)&start];
vector(8) long int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: SR.50_41 = MEM[(const struct time_point *)&stop];
vector(8) long int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: _34 = cout._vptr.basic_ostream;
vector(8) long unsigned int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: _35 = MEM[(long int *)_34 + -24B];
vector(8) long int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: __old_65 = _37->_M_flags;
vector(16) signed int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: MEM[(_Ios_Fmtflags &)_37 + 24] = _67;
vector(16) signed int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: MEM[(streamsize *)_37 + 8B] = 9;
vector(8) long int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: _43 = MEM[(long int *)_34 + -24B];
vector(8) long int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: __old_62 = _45->_M_flags;
vector(16) signed int
/usr/include/c++/7/ostream:562:44: note: got vectype for stmt: MEM[(_Ios_Fmtflags &)_45 + 24] = _64;
vector(16) signed int
/usr/include/c++/7/ostream:562:44: note: === vect_analyze_data_ref_accesses ===
/usr/include/c++/7/ostream:562:44: note: not consecutive access __old_65 = _37->_M_flags;
/usr/include/c++/7/ostream:562:44: note: not consecutive access MEM[(streamsize *)_37 + 8B] = 9;
/usr/include/c++/7/ostream:562:44: note: not consecutive access MEM[(_Ios_Fmtflags &)_37 + 24] = _67;
/usr/include/c++/7/ostream:562:44: note: not consecutive access __old_62 = _45->_M_flags;
/usr/include/c++/7/ostream:562:44: note: not consecutive access MEM[(_Ios_Fmtflags &)_45 + 24] = _64;
/usr/include/c++/7/ostream:562:44: note: not consecutive access _34 = cout._vptr.basic_ostream;
/usr/include/c++/7/ostream:562:44: note: not consecutive access SR.52_40 = MEM[(const struct time_point *)&start];
/usr/include/c++/7/ostream:562:44: note: not consecutive access SR.50_41 = MEM[(const struct time_point *)&stop];
/usr/include/c++/7/ostream:562:44: note: not consecutive access _35 = MEM[(long int *)_34 + -24B];
/usr/include/c++/7/ostream:562:44: note: not consecutive access _43 = MEM[(long int *)_34 + -24B];
/usr/include/c++/7/ostream:562:44: note: not vectorized: no grouped stores in basic block.
/usr/include/c++/7/ostream:561:2: note: === vect_analyze_data_refs ===
/usr/include/c++/7/ostream:561:2: note: not vectorized: not enough data-refs in basic block.
/usr/include/c++/7/ostream:561:2: note: === vect_analyze_data_refs ===
/usr/include/c++/7/ostream:561:2: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:63:1: note: === vect_analyze_data_refs ===
lcg.cpp:63:1: note: not vectorized: not enough data-refs in basic block.
lcg.cpp:63:1: note: ===vect_slp_analyze_bb===
lcg.cpp:63:1: note: === vect_analyze_data_refs ===
lcg.cpp:63:1: note: not vectorized: not enough data-refs in basic block.
